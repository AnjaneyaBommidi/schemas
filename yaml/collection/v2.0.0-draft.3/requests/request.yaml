title: Postman Request
description: >-
  Contains a full HTTP request, including headers, form fields, request body, and possibly one or more responses.
type: object
required:
  - method
  - url
properties:
  name:
    $ref: ../types.yaml#/definitions/Name
  description:
    $ref: ../types.yaml#/definitions/Description
  variables:
    $ref: ../variables.yaml
  url:
    type: string
    minLength: 0
    description: >
      The request URL (e.g. "http://company.com/api/v1/users?username=jdoe"). You can use variables
      in double curly brackets anywhere in the URL string
      (e.g. `{{protocol}}://{{server_name}}:{{port_number}}/api/{{version_number}}/users?username={{user_name}}`).
  method:
    type: string
    minLength: 1
    enum: [GET, PUT, POST, PATCH, DELETE, COPY, HEAD, OPTIONS, LINK, UNLINK, PURGE, LOCK, UNLOCK, PROPFIND, VIEW]
    description: The HTTP method associated with this request
  headers:
    $ref: ../types.yaml#/definitions/StringMap
    description: >
      The HTTP request headers, as set of name/value pairs.
      Each name and/or value can contain variable names in double curly brackets (e.g. `{{AUTH_HEADER_NAME}}`)
  cookies:
    $ref: cookies.yaml
    description: A structured version of the "Cookie" request header
  body:
    $ref: "#/definitions/RequestBody"
  events:
    $ref: "#/definitions/Events"
  responses:
    $ref: "#/definitions/Responses"

patternProperties:
  "^_":
    $ref: ../types.yaml#/definitions/AnyType
additionalProperties: false

definitions:
  RequestBody:
    description: >-
      The HTTP request body.  Depending on the content-type, the body may be
      URL-encoded name/value pairs, multipart form data (fields and files), binary data (often base64-encoded),
      plain text, HTML, or any of a variety of data formats, such as as JSON, XML, CSV, SOAP, etc.
    oneOf:
      - $ref: "#/definitions/UrlEncodedRequestBody"
      - $ref: "#/definitions/MultiPartRequestBody"
      - $ref: "#/definitions/RawRequestBody"
      - $ref: "#/definitions/BinaryRequestBody"

  UrlEncodedRequestBody:
    type: object
    description: >-
      A `application/x-www-form-urlencoded` request body contains name/value pairs.
      Each name and value is a string consisting of ASCII characters (special characters are escaped or encoded).
      Each pair is delimited by an ampersand ("&"), and each name and value are separated by an
      equals sign ("=").
      For example: `name=John+Doe&age=35&hairColor=brown`.
    required:
      - mode
    properties:
      mode:
        type: string
        enum: [urlencoded]
      fields:
        $ref: ../types.yaml#/definitions/StringMap
        description: >-
          Field names or values can be contain variables in double curly brackets (e.g. `{{Some_Value}}`)
    patternProperties:
      "^_":
        $ref: ../types.yaml#/definitions/AnyType
    additionalProperties: false

  MultiPartRequestBody:
    type: object
    description: >-
      A `multipart/form-data` request body contains name/value pairs, just like an
      `application/x-www-form-urlencoded` request body.  The difference is that urlencoded values
      are limited to strings of ASCII characters, whereas multipart values can contain non-ASCII
      characters and even encoded binary data.  Each name/value pair in a multipart request is
      sent as a separate "part" of the HTTP reqeust, and may contain its own HTTP headers,
      such as Content-Type, Content-Disposition, Content-Transfer-Encoding, etc.
    required:
      - mode
    properties:
      mode:
        type: string
        enum: [multipart]
      fields:
        $ref: ../types.yaml#/definitions/StringMap
        description: >-
          Field names or values can be contain variables in double curly brackets (e.g. `{{Some_Value}}`)
    patternProperties:
      "^_":
        $ref: ../types.yaml#/definitions/AnyType
    additionalProperties: false

  RawRequestBody:
    type: object
    description: >-
      A "raw" request body can contain plain text, HTML, CSV, JSON, XML, encoded binary data,
      or any other text-based content.  The destination server will determine the type of content
      based on HTTP headers, such as Content-Type, Content-Disposition, Content-Encoding, etc.
    required:
      - mode
    properties:
      mode:
        type: string
        enum: [raw]
      content:
        $ref: ../types.yaml#/definitions/EncodedStringOrJson
        description: >
          This will be a string for most content types (plain text, HTML, CSV, XML, etc.),
          but for JSON content, you may specify an object, which will be serialized as JSON when
          the request is sent.
    patternProperties:
      "^_":
        $ref: ../types.yaml#/definitions/AnyType
    additionalProperties: false

  BinaryRequestBody:
    type: object
    description: >-
      A "binary" request body is binary data (such as an image, audio file, etc.) that is encoded
      as ASCII text.  The Content-Encoding header determines the encoding type.
    required:
      - mode
    properties:
      mode:
        type: string
        enum: [binary]
      content:
        $ref: ../types.yaml#/definitions/EncodedString
    patternProperties:
      "^_":
        $ref: ../types.yaml#/definitions/AnyType
    additionalProperties: false

  Events:
    type: object
    properties:
      onRequest:
        $ref: scripting.yaml#/definitions/EventHandler
        description: >-
          This event fires when the request is about to be sent.  It's a good opportunity to populate
          environment variables that are needed by the request.
      onResponse:
        $ref: scripting.yaml#/definitions/EventHandler
        description: >-
          This event fires when the response is received.  It's a good opportunity to save parts of
          the response as environment variables, or to manipulate the response to prepare it for
          the `onTest` event.
      onTest:
        $ref: scripting.yaml#/definitions/EventHandler
        description: >-
          This event fires after the `onResponse` event.  This is where you should make assertions
          on the response. You can set properties of the `tests` object to indicate test passed or
          failed tests (e.g. `tests.hasUsername = JSON.parse(responseBody).username.length > 0`).
    patternProperties:
      "^_":
        $ref: ../types.yaml#/definitions/AnyType
    additionalProperties: false

  Responses:
    type: array
    minItems: 0
    items:
      $ref: response.yaml
    description: >-
      Postman allows you to store multiple responses for a request.  This is useful for example
      requests, so you can include examples of different possible responses.  It's also useful for
      debugging purposes, where you may want to save multiple responses for reference purposes.
